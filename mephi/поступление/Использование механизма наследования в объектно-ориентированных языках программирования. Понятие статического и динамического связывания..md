[[Билеты.pdf#page=6&selection=172,0,185,66|Билет N]]
### Использование механизма наследования в объектно-ориентированных языках программирования 
==Наследование== — это механизм, позволяющий одному классу (называемого дочерним классом) наследовать свойства и методы другого класса (называемого родительским классом). Это позволяет создавать новый класс на основе уже существующего, что способствует повторному использованию кода и улучшает его структуру.
Возможности, получаемые при использовании наследования:
1. **Повторное использование кода:** Дочерний класс наследует поля и методы родительского класса, что позволяет избежать дублирования кода.
2. **Расширяемость:** Дочерний класс может добавлять новые поля и методы или переопределять существующие методы родительского класса.
3. **Полиморфизм:** Наследование способствует реализации полиморфизма, позволяя объекту одного типа принимать форму другого типа.
Пример кода на питоне:
```python
class Animal:
    def speak(self):
        print("Animal speaks")

class Dog(Animal):
    def speak(self):
        print("Dog barks")

# Создание объекта класса Dog
dog = Dog()
dog.speak()  # Вывод: Dog barks
```
В приведенном примере выше показано переопределение дочерним классом Dog родительского  метода speak Animal.
### Понятие статического и динамического связывания ###
==Связывание== — это процесс ассоциации вызова метода с его телом (реализацией). Существует два типа связывания: статическое и динамическое.
Статическое связывание происходит во время компиляции. Компилятор определяет, какой метод будет вызван, исходя из типа ссылки на объект. Это связывание используется для методов, которые не являются виртуальными или не переопределяются в наследниках.
Динамическое связывание происходит во время выполнения программы. Оно используется для виртуальных методов и позволяет вызвать переопределенный метод в производном классе, даже если вызов идет через указатель или ссылку на базовый класс.
Пример динамического связывания с помощью виртуальных функций на C++:
```cpp
class Base {
public:
    virtual void show() {
        cout << "Base::show() called" << endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        cout << "Derived::show() called" << endl;
    }
};

int main() {
    Base b;
    Derived d;
    Base *bptr;
    
    bptr = &b;
    bptr->show();  // Вывод: Base::show() called
    
    bptr = &d;
    bptr->show();  // Вывод: Derived::show() called, так как связывание динамическое
}
```
### Пояснение за виртуальные методы ###
> [!info]
> Виртуальные методы — это концепция ООП, используемая в компилируемых языках программирования. Они позволяют создавать методы в базовом классе, которые могут быть переопределены в производных классах.
> Основное отличие между виртуальными и обычными методами заключается в том, как они обрабатываются при вызове через указатели или ссылки на базовый класс. Виртуальные методы позволяют реализовать полиморфизм и позднее связывание, что делает код более гибким и расширяемым, тогда как обычные методы имеют фиксированное поведение, определенное на этапе компиляции.
> Для поддержки виртуальных методов используется структура данных, называемая таблицей виртуальных методов (vtable). Эта таблица хранит указатели на функции, соответствующие методам объекта. Каждому классу с виртуальными методами соответствует своя vtable.вать полиморфизм и позднее связывание, что делает код более гибким и расширяемым, тогда как обычные методы имеют фиксированное поведение, определенное на этапе компиляции.

Если нихуя не понятно: https://ravesli.com/urok-163-virtualnye-funktsii-i-polimorfizm/ (нужен vpn)