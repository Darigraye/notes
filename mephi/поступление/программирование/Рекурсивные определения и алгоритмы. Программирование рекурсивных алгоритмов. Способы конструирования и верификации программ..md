[[Билеты.pdf#page=6&selection=116,0,127,59|Билет N]]
### Рекурсивные определения и алгоритмы ###
==Рекурсия== — это процесс, при котором функция вызывает саму себя. Рекурсивные определения — это определения объектов или функций, которые включают самих себя в своем определении. Например, рекурсивное определение факториала числа n можно записать так:
1. Базовый случай: 0!=10! = 10!=1
2. Рекурсивный случай: n!=n×(n−1)!n! = n \times (n-1)!n!=n×(n−1)! для n>0
Рекурсивные алгоритмы используют рекурсивные определения для решения задач. Основные шаги при написании рекурсивных алгоритмов:
1. **Базовый случай**: Определить условия завершения рекурсии, чтобы избежать бесконечных вызовов.
2. **Рекурсивный случай**: Определить, как функция будет вызывать саму себя.
### Программирование рекурсивных алгоритмов ###
Пример алгоритма вычисления факториала на python:
```python
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
```
**Преимущества:**
1. **Читаемость**: Рекурсивные алгоритмы могут быть проще и короче, чем их итерационные аналоги.
2. **Простота реализации**: Некоторые задачи, такие как обход деревьев или графов, проще решить с помощью рекурсии.
**Недостатки:**
1. **Производительность**: Рекурсивные алгоритмы могут быть менее эффективны из-за накладных расходов на вызов функций и возможных переполнений стека.
2. **Память**: Рекурсия может потреблять больше памяти из-за множества вложенных вызовов.
### Способы конструирования и верификации программ ###
Конструирование программ с рекурсией включает в себя несколько шагов, чтобы обеспечить правильность и эффективность рекурсивного решения:
1. **Определение проблемы**:
    - Четко определить задачу, которую нужно решить.
    - Определить, может ли задача быть решена с помощью рекурсии.
2. **Определение базового случая**:
    - Базовый случай — это условие, при котором рекурсия прекращается.
    - Базовый случай должен быть простым и решаемым без дальнейших рекурсивных вызовов.
3. **Разделение на подзадачи**:
    - Определить, как можно разделить задачу на меньшие подзадачи, решение которых приводит к решению исходной задачи.
    - Каждая подзадача должна быть аналогична исходной задаче, но проще.
4. **Рекурсивный случай**:
    - Определить, как будет решаться каждая подзадача рекурсивно.
    - Убедиться, что каждое рекурсивное решение приближает задачу к базовому случаю.
5. **Объединение результатов**:    
    - Определить, как объединить результаты подзадач для получения решения исходной задачи.
#### Пример: Быстрая сортировка (Quick Sort)
1. **Определение проблемы**: Отсортировать массив чисел.
2. **Базовый случай**: Массив из одного элемента или пустой массив уже отсортирован.
3. **Разделение на подзадачи**: Разделить массив на элементы, меньшие и большие опорного элемента (pivot).
4. **Рекурсивный случай**: Рекурсивно отсортировать подмассивы.
5. **Объединение результатов**: Объединить отсортированные подмассивы и опорный элемент.
Пример кода на python:
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```
Верификация рекурсивных программ заключается в проверке правильности их работы. Это включает в себя несколько методов:
1. **Тестирование базовых случаев**:
    - Проверить, что базовый случай работает правильно.
    - Базовый случай должен возвращать ожидаемый результат без дальнейших рекурсивных вызовов.
2. **Тестирование граничных случаев**:
    - Проверить, как программа ведет себя при крайних значениях входных данных.
3. **Анализ инвариантов**:
    - Определить инварианты, то есть условия, которые остаются истинными до и после выполнения функции.
    - Проверить, что инварианты выполняются на каждом этапе рекурсии.
4. **Математическая индукция**:
    - Использовать метод математической индукции для доказательства правильности рекурсивной функции.
    - Доказать, что функция работает правильно для базового случая.
    - Показать, что если функция работает правильно для некоторого случая nnn, то она работает правильно и для случая n+1n+1n+1.
#### Пример: Верификация функции вычисления факториала
1. **Базовый случай**:
    - 0!=10! = 10!=1 правильно.
2. **Рекурсивный случай**:
    - Предположим, что factorial(n)factorial(n)factorial(n) правильно для nnn.
    - Нужно показать, что factorial(n+1)=(n+1)×factorial(n)factorial(n+1) = (n+1) \times factorial(n)factorial(n+1)=(n+1)×factorial(n).
3. **Индукционный шаг**:
    - Если factorial(n)=n!factorial(n) = n!factorial(n)=n!, то factorial(n+1)=(n+1)×n!=(n+1)!factorial(n+1) = (n+1) \times n! = (n+1)!factorial(n+1)=(n+1)×n!=(n+1)!.
> [!important] 
 > При тестировании рекурсивных программ нужно обращать внимание на производительность, при необходимости производить оптимизацию переводом на итеративный алгоритм, либо использовать мемоизацию (хранение вычисленных ранее данных в памяти для избежания повторного вычисления и хранения в ОП)
    